<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>golang on Yunfan Zhang</title>
    <link>https://fanhide.github.io/categories/golang/</link>
    <description>Recent content in golang on Yunfan Zhang</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <lastBuildDate>Sat, 31 Aug 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://fanhide.github.io/categories/golang/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>对互斥锁与读写锁的理解</title>
      <link>https://fanhide.github.io/blog/mutex/</link>
      <pubDate>Sat, 31 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fanhide.github.io/blog/mutex/</guid>
      <description> Introduction sync 官方推荐在使用goroutine时，使用管道[channel]来进行通信。不建议使用共享内存的方式。 但提供了[sync]，通过锁等机制协同操作的包。
sync Locker sync定义了Locker结构定义锁
type Locker interface { Lock() Unlock() }  并且创造了两个结构来实现Locker接口：Mutex 和 RWMutex。
Mutex就是互斥锁，互斥锁代表着当数据被加锁了之后，除了加锁的程序，其他程序不能对数据进行读操作和写操作。 这个当然能解决并发程序对资源的操作。但是，效率上是个问题。当加锁后，其他程序要读取操作数据，就只能进行等待了。 这个时候就需要使用读写锁。
mu.Lock() _, err := writer.Write([]byte(data)) if err != nil { log.Printf(&amp;quot;error: %s [%d]&amp;quot;, err, id) } mu.Unlock()  互斥锁的注意事项： 1. 不要重复锁定互斥锁
 不要忘记解锁互斥锁，必要时通过defer
 不要对未锁定的互斥锁解锁，或者对已经解锁的互斥锁解锁
 不要在多个函数间传递互斥锁 以上情况，都比较容易出现锁的争用，从而导致死锁。
  所谓的死锁，指的就是当前程序中的主 goroutine，以及启用的goroutine被阻塞。
读写锁分为读锁和写锁，读数据的时候上读锁，写数据的时候上写锁。有写锁的时候，数据不可读不可写。有读锁的时候，数据可读，不可写。
 </description>
    </item>
    
    <item>
      <title>go的逃逸分析</title>
      <link>https://fanhide.github.io/blog/golang/</link>
      <pubDate>Sun, 25 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fanhide.github.io/blog/golang/</guid>
      <description>逃逸分析是指 在编译原理中，分析指针动态范围的方法称之为逃逸分析。通俗来讲，当一个对象的指针被多个方法或线程引用时，我们称这个指针发生了逃逸。
Go语言的逃逸分析是编译器执行静态代码分析后，对内存管理进行的优化和简化，它可以决定一个变量是分配到堆还栈上。
写过C/C++的同学都知道，调用著名的malloc和new函数可以在堆上分配一块内存，这块内存的使用和销毁的责任都在程序员。一不小心，就会发生内存泄露。
Go语言里，基本不用担心内存泄露了。虽然也有new函数，但是使用new函数得到的内存不一定就在堆上。堆和栈的区别对程序员“模糊化”了，当然这一切都是Go编译器在背后帮我们完成的。
Go语言逃逸分析最基本的原则是：如果一个函数返回对一个变量的引用，那么它就会发生逃逸。
简单来说，编译器会分析代码的特征和代码生命周期，Go中的变量只有在编译器可以证明在函数返回后不会再被引用的，才分配到栈上，其他情况下都是分配到堆上。
Go语言里没有一个关键字或者函数可以直接让变量被编译器分配到堆上，相反，编译器通过分析代码来决定将变量分配到何处。
对一个变量取地址，可能会被分配到堆上。但是编译器进行逃逸分析后，如果考察到在函数返回后，此变量不会被引用，那么还是会被分配到栈上。
编译器会根据变量是否被外部引用来决定是否逃逸：
 如果函数外部没有引用，则优先放到栈中； 如果函数外部存在引用，则必定放到堆中；  最佳方式 写C/C++代码时，为了提高效率，常常将pass-by-value（传值）“升级”成pass-by-reference，企图避免构造函数的运行，并且直接返回一个指针。
你一定还记得，这里隐藏了一个很大的坑：在函数内部定义了一个局部变量，然后返回这个局部变量的地址（指针）。这些局部变量是在栈上分配的（静态内存分配），一旦函数执行完毕，变量占据的内存会被销毁，任何对这个返回值作的动作（如解引用），都将扰乱程序的运行，甚至导致程序直接崩溃。比如下面的这段代码：
int *foo ( void ) { int t = 3; return &amp;amp;t; }  有些同学可能知道上面这个坑，用了个更聪明的做法：在函数内部使用new函数构造一个变量（动态内存分配），然后返回此变量的地址。因为变量是在堆上创建的，所以函数退出时不会被销毁。但是，这样就行了吗？new出来的对象该在何时何地delete呢？调用者可能会忘记delete或者直接拿返回值传给其他函数，之后就再也不能delete它了，也就是发生了内存泄露。关于这个坑，大家可以去看看《Effective C++》条款21，讲得非常好！
前面讲的C/C++中出现的问题，在Go中作为一个语言特性被大力推崇。真是C/C++之砒霜Go之蜜糖！
C/C++中动态分配的内存需要我们手动释放，导致我们平时在写程序时，如履薄冰。这样做有他的好处：程序员可以完全掌控内存。但是缺点也是很多的：经常出现忘记释放内存，导致内存泄露。所以，很多现代语言都加上了垃圾回收机制。
逃逸分析这种“骚操作”把变量合理地分配到它该去的地方。即使你是用new申请到的内存，如果我发现你竟然在退出函数后没有用了，那么就把你丢到栈上，毕竟栈上的内存分配比堆上快很多；反之，即使你表面上只是一个普通的变量，但是经过逃逸分析后发现在退出函数之后还有其他地方在引用，那我就把你分配到堆上。
如果变量都分配到堆上，堆不像栈可以自动清理。它会引起Go频繁地进行垃圾回收，而垃圾回收会占用比较大的系统开销（占用CPU容量的25%）。
堆和栈相比，堆适合不可预知大小的内存分配。但是为此付出的代价是分配速度较慢，而且会形成内存碎片。栈内存分配则会非常快。栈分配内存只需要两个CPU指令：“PUSH”和“RELEASE”，分配和释放；而堆分配内存首先需要去找到一块大小合适的内存块，之后要通过垃圾回收才能释放。
通过逃逸分析，可以尽量把那些不需要分配到堆上的变量直接分配到栈上，堆上的变量少了，会减轻分配堆内存的开销，同时也会减少gc的压力，提高程序的运行速度。
实例 如何查看某个变量是否发生了逃逸？ 两种方法：使用go命令，查看逃逸分析结果；反汇编源码；
实例1 package main import &amp;quot;fmt&amp;quot; func foo() *int { t := 3 return &amp;amp;t; } func main() { x := foo() fmt.Println(*x) }  使用go命令
go build -gcflags &#39;-m -l&#39; main.</description>
    </item>
    
    <item>
      <title>docker源码分析</title>
      <link>https://fanhide.github.io/blog/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</link>
      <pubDate>Sat, 17 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fanhide.github.io/blog/docker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</guid>
      <description>docker cli 数据结构 // DockerCli结构 type DockerCli struct { proto string	// (Client和Server直接的传输类型)协议类型 tcp、unix、fd addr string	// Docker需要访问host的目标 configFile *registry.ConfigFile // for what ? in io.ReadCloser	// 读和关闭接口 out io.Writer // 写接口 err io.Writer	// 错误输出接口 isTerminal bool	// 终端相关？ terminalFd uintptr	// 文件句柄 tlsConfig *tls.Config	// tls配置 scheme string	// 指示http或者https }  结构体包含的方法 // 创建DockerCli对象。(工厂模式) func NewDockerCli(in io.ReadCloser, out, err io.Writer, proto, addr string, tlsConfig *tls.Config) *DockerCli { var ( isTerminal = false terminalFd uintptr scheme = &amp;quot;http&amp;quot; ) // 如果有tls配置那么使用https协议。 if tlsConfig !</description>
    </item>
    
  </channel>
</rss>