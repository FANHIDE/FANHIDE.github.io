<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>mutex on Yunfan Zhang</title>
    <link>https://fanhide.github.io/categories/mutex/</link>
    <description>Recent content in mutex on Yunfan Zhang</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <lastBuildDate>Sat, 31 Aug 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://fanhide.github.io/categories/mutex/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>对互斥锁与读写锁的理解</title>
      <link>https://fanhide.github.io/blog/mutex/</link>
      <pubDate>Sat, 31 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fanhide.github.io/blog/mutex/</guid>
      <description> Introduction sync 官方推荐在使用goroutine时，使用管道[channel]来进行通信。不建议使用共享内存的方式。 但提供了[sync]，通过锁等机制协同操作的包。
sync Locker sync定义了Locker结构定义锁
type Locker interface { Lock() Unlock() }  并且创造了两个结构来实现Locker接口：Mutex 和 RWMutex。
Mutex就是互斥锁，互斥锁代表着当数据被加锁了之后，除了加锁的程序，其他程序不能对数据进行读操作和写操作。 这个当然能解决并发程序对资源的操作。但是，效率上是个问题。当加锁后，其他程序要读取操作数据，就只能进行等待了。 这个时候就需要使用读写锁。
mu.Lock() _, err := writer.Write([]byte(data)) if err != nil { log.Printf(&amp;quot;error: %s [%d]&amp;quot;, err, id) } mu.Unlock()  互斥锁的注意事项： 1. 不要重复锁定互斥锁
 不要忘记解锁互斥锁，必要时通过defer
 不要对未锁定的互斥锁解锁，或者对已经解锁的互斥锁解锁
 不要在多个函数间传递互斥锁 以上情况，都比较容易出现锁的争用，从而导致死锁。
  所谓的死锁，指的就是当前程序中的主 goroutine，以及启用的goroutine被阻塞。
读写锁分为读锁和写锁，读数据的时候上读锁，写数据的时候上写锁。有写锁的时候，数据不可读不可写。有读锁的时候，数据可读，不可写。
 </description>
    </item>
    
  </channel>
</rss>