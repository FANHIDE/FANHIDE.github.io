<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>RWmutex on Yunfan Zhang</title>
    <link>https://fanhide.github.io/tags/rwmutex/</link>
    <description>Recent content in RWmutex on Yunfan Zhang</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <lastBuildDate>Sat, 31 Aug 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://fanhide.github.io/tags/rwmutex/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>对互斥锁与读写锁的理解</title>
      <link>https://fanhide.github.io/blog/mutex/</link>
      <pubDate>Sat, 31 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://fanhide.github.io/blog/mutex/</guid>
      <description> Introduction sync 官方推荐在使用goroutine时，使用管道[channel]来进行通信。不建议使用共享内存的方式。 但提供了[sync]，通过锁等机制协同操作的包。
sync Locker sync定义了Locker结构定义锁
type Locker interface { Lock() Unlock() }  并且创造了两个结构来实现Locker接口：Mutex 和 RWMutex。
Mutex就是互斥锁，互斥锁代表着当数据被加锁了之后，除了加锁的程序，其他程序不能对数据进行读操作和写操作。 这个当然能解决并发程序对资源的操作。但是，效率上是个问题。当加锁后，其他程序要读取操作数据，就只能进行等待了。 这个时候就需要使用读写锁。
读写锁分为读锁和写锁，读数据的时候上读锁，写数据的时候上写锁。有写锁的时候，数据不可读不可写。有读锁的时候，数据可读，不可写。 互斥锁就不举例子，读写锁可以看下面的例子：
 </description>
    </item>
    
  </channel>
</rss>